[
{
	"uri": "/chapters/flask-co-ban/xay-dung-url/",
	"title": "Xây dựng URL",
	"tags": [],
	"description": "",
	"content": " Kỹ thuật Routing Routing (điều hướng) là một kỹ thuật cơ bản giúp truy cập 1 chức năng qua URL.\nKỹ thuật này rất đơn giản,\nMọi request browser gửi tới đều đi qua một Router (bộ điều hướng), có tác dụng dựa vào URL và Method để định vị xem cần dùng hàm nào để xử lý. graph LR A[fa:fa-user Browser] --|POST /users| C{Router} C --|run this function| D[user_new] C -.- E[user_index] C -.- F[item_index]  Routing với Flask Chúng ta sẽ thử xem với Flask, ta sẽ thực hiện routing như thế nào.\nGõ đoạn code sau và lưu lại với tên app.py\nfrom flask import Flask app = Flask(__name__) @app.route('/users') def user_index(): return 'Hello, this is user list' @app.route('/users', methods=['POST']) def user_new(): return 'Create new user' @app.route('/items', methods=['GET']) def item_index(): return 'This is item list' if __name__ == '__main__': app.run()  Chạy server:\npython app.py   * Serving Flask app \u0026quot;app\u0026quot; (lazy loading) * Environment: production WARNING: Do not use the development server in a production environment. Use a production WSGI server instead. * Debug mode: off * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)  Tiếp theo chúng ta sẽ thử giả lập browser tạo 1 số request. Mở tab mới của terminal (thường là Ctrl+Shift+T) và chạy thử câu lệnh sau:\ncurl -X GET http://127.0.0.1:5000/users  Kết quả:\n➜ ~ curl -X GET http://127.0.0.1:5000/users Hello, this is user list%  CURL là một phần mềm CLI (giao diện dòng lệnh) giúp gửi và nhận request. Bạn cũng có thể test API bằng phần mềm này!\n Hãy thử lần lượt với POST /users, GET /items xem kết quả thế nào nhé.\n@app.route Nhìn lại đoạn code ở ví dụ trên, ta có thể hình dung cách sử dụng route trong flask như sau:\n@app.route(URL, methods) def some_function(): ...  Trong đó:\n URL là đường dẫn được gán với hàm xử lý some_function()\n Methods là một mảng Method được chấp nhận. Nếu không khai báo, Methods sẽ mặc định = [\u0026lsquo;GET\u0026rsquo;]\n  @app.route là một decorator, về cơ bản thì nó cần được đặt ở ngay trước phần khai báo hàm.\n "
},
{
	"uri": "/chapters/flask-co-ban/url-nang-cao/",
	"title": "URL nâng cao",
	"tags": [],
	"description": "",
	"content": " URL Động Ở bài trước, ta đã học cách sử dụng routing cơ bản. Bài này ta sẽ tiếp cận với một vấn đề khó hơn: URL động\nTa cần định nghĩa URL trong `@app.route** để router có thể điều hướng chính xác. Vậy làm thế nào để xử lý với những URL có thể bị thay đổi?\nVí dụ Lưu file sau với tên hello.py\nfrom flask import Flask app = Flask(__name__) @app.route('/hello/\u0026lt;name\u0026gt;') def hello_name(name): return 'Hello %s!' % name if __name__ == '__main__': app.run(debug = True)  Chạy server python hello.py và thử một số request sau:\ncurl -X GET http://127.0.0.1:5000/hello/Chien Hello Chien!%  curl -X GET http://127.0.0.1:5000/hello/SomeNameSoLong Hello SomeNameSoLong!%  Làm thế nào? Một lần nữa nhìn vào code ta có thể dễ dàng nhận ra, ta có thể đưa biến vào URL bằng dấu \u0026lt;\u0026gt; như sau \u0026lt;variable_name\u0026gt;\nNhư ví dụ trên\n@app.route('/hello/\u0026lt;name\u0026gt;') def hello_name(name):  Khi user truy cập /hello/Chien thì \u0026lsquo;Chien\u0026rsquo; sẽ được gán vào biến name.\nKết quả ta có:\nHello Chien!  Mặc định biến URL sẽ có kiểu string. Ngoài ra, ta có thể định nghĩa kiểu dữ liệu cho biến với cấu trúc sau: \u0026lt;kiểu DL:Tên biến\u0026gt;\nVí dụ: \u0026lt;int:soNguyen\u0026gt; , \u0026lt;float:soThuc\u0026gt;\nBài tập Sử dụng URL động để xây dựng ứng dụng cộng, trừ 2 số nguyên\nKhi truy cập http://127.0.0.1:5000/sum/1/2\nKết quả trả về:\n1+2=3  Khi truy cập http://127.0.0.1:5000/sub/5/2\nKết quả trả về:\n5-2=3  "
},
{
	"uri": "/chapters/flask-co-ban/gioi-thieu-template/",
	"title": "Giới thiệu Template",
	"tags": [],
	"description": "",
	"content": " Giải bài phần trước from flask import Flask app = Flask(__name__) @app.route('/sum/\u0026lt;int:a\u0026gt;/\u0026lt;int:b\u0026gt;') def sum(a,b): return '%s + %s = %s' % (a, b, a+b) @app.route('/sub/\u0026lt;int:a\u0026gt;/\u0026lt;int:b\u0026gt;') def sub(a,b): return '%s - %s = %s' % (a, b, a-b) if __name__ == '__main__': app.run(debug = True)  Giới thiệu Chúng ta cùng thử nghiệm một demo nhỏ như sau:\nLưu lại với file hello.py:\nfrom flask import Flask app = Flask(__name__) @app.route('/') def index(): return '\u0026lt;html\u0026gt;\u0026lt;body\u0026gt;\u0026lt;h1\u0026gt;Hello World\u0026lt;/h1\u0026gt;\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt;' if __name__ == '__main__': app.run(debug = True)  Chạy server: python hello.py\nKết quả: Như vậy, ta có thể sử dụng HTML ngay trong phần return của hàm.\nTuy nhiên, khi mà HTML trở nên phức tạp. Ta sẽ gặp khó khăn trong việc phải sử dụng một đống các hàm xử lý xâu, vòng lặp để tạo ra 1 xâu HTML như ý để trả về cho browser.\nNgoài ra, code frontend và backend bị mix với nhau cũng khá là khó chịu và xấu (smell code)\nVì thế ta sẽ đến với 1 phương pháp tốt hơn, gọi là Template\nThử sử dụng Template Đầu tiên sửa lại file hello.py như sau:\nfrom flask import Flask from flask import render_template app = Flask(__name__) @app.route('/') def index(): return render_template('hello.html') if __name__ == '__main__': app.run(debug = True)  Tiếp theo, tạo 1 thư mục templates ngang hàng với file hello.py\nTạo tiếp 1 file hello.html trong thư mục templates:\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello World\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  Cây thư mục sẽ như sau nếu bạn tạo đúng:\n├── hello.py └── templates └── hello.html  Chạy server python hello.py. Ta đã tách phần HTML ra 1 file khác nhưng kết quả vẫn không đổi.\nĐiều gì đã xảy ra? Đầu tiên, hàm render_template ta sử dụng ở dòng sau:\nreturn render_template('hello.html')  không phải là một hàm có sẵn (built-in function) của python. Vì thế mà ta cần dòng lệnh import này:\nfrom flask import render_template  Các lệnh import có thể đặt ở bất cứ đâu. Tuy nhiên, chúng thường được đặt ở ngay đầu file.\n Nhiệm vụ của hàm render_template là tìm kiếm trong thư mục templates xem có file nào tên là hello.html hay không.\nNếu có, nó sẽ lấy ra và truyền dữ liệu vào nếu cần thiết. Cuối cùng là trả về 1 nội dung HTML hoàn chỉnh.\nNếu không, nó sẽ báo lỗi.\ngraph LR A{Find template file} --|Found it| B(fa:fa-spinner Fill data) B -- C(return html code) A --|Not found| D(fa:fa-ban Raise an error)  Truyền dữ liệu Phần trước có đề cập đến truyền dữ liệu, vậy truyền dữ liệu là như thế nào?\nTa sửa file templates/hello.html như sau:\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello {{ name }}\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  Sửa tiếp file hello.py:\nreturn render_template('hello.html', name='Chien')  Chạy server python hello.py và xem kết quả, lần này ta dùng curl http://127.0.0.1:5000/\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello Chien\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;%  {{ name }} đã được thay bằng Chien. Như vậy công đoạn truyền dữ liệu tức là đưa dữ liệu thật từ bên ngoài vào trong template.\nTổng kết Khái quát lại, ta có cấu trúc của hàm render_template như sau:\nrender_template(template_file[, var1, var2,..])  Dấu [...] trong cấu trúc có nghĩa là có thể có hoặc không (không bắt buộc).\n Số lượng biến truyền vào hàm render_template là vô hạn. Có thể truyền nhiều kiểu dữ liệu (list, dict, ..), không nhất thiết phải là string\n Bài tập Áp dụng render_template vào bài tập phần trước.\nYêu cầu chỉ sử dụng một file template cho cả 2 hàm sum và sub.\n"
},
{
	"uri": "/chapters/flask-co-ban/static-file/",
	"title": "Static File",
	"tags": [],
	"description": "",
	"content": " Giải bài phần trước: File app.py:\nfrom flask import Flask from flask import render_template app = Flask(__name__) @app.route('/sum/\u0026lt;int:a\u0026gt;/\u0026lt;int:b\u0026gt;') def sum(a, b): return render_template('ketqua.html', a=a, b=b, c=a+b, phep='+') @app.route('/sub/\u0026lt;int:a\u0026gt;/\u0026lt;int:b\u0026gt;') def sub(a, b): return render_template('ketqua.html', a=a, b=b, c=a-b, phep='-') if __name__ == '__main__': app.run(debug = True)  File templates/ketqua.html\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;{{ a }} {{ phep }} {{ b }} = {{ c }}\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  File tĩnh/File tài nguyên Các ứng dụng web thường cần thêm những file tĩnh (như file css, javascript,..). Flask đặc biệt hỗ trợ một nơi lưu trữ các file này đó là thư mục static/\nTạo 1 file static/style.css, cây thư mục như sau:\n├── hello.py ├── static │ └── style.css └── templates └── hello.html  Nội dung file style.css\nh1 { color: blue; }  Dùng hàm url_for() để lấy đường dẫn của file style.css. Sửa file hello.html thành như sau:\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;{{ url_for('static', filename='style.css') }}\u0026quot; /\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello {{ name }}\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  Kết quả: Output Source:\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;/static/style.css\u0026quot; /\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello Chien\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  Ta thấy, kết quả của hàm:\nurl_for('static', filename='style.css')  là /static/style.css và CSS đã hoạt động.\n Hỏi: Vậy tại sao không dùng luôn /static/style.css cho nhanh?\nĐáp: Khi làm project thực tế ta sẽ đưa tất cả file trong project vào 1 thư mục, khi đó việc định vị file css sẽ khó khăn hơn. Hàm url_for sẽ hoạt động tốt trong trường hợp này.\n "
},
{
	"uri": "/chapters/flask-co-ban/lam-quen-voi-request/",
	"title": "Làm quen với object request",
	"tags": [],
	"description": "",
	"content": " Request Object Như đã biết, các thông tin mà browser gửi lên server được chứa trong Request Vậy làm sao để lấy các dữ liệu đó ra?\nFlask cung cấp một object gọi là request, chứa các thông tin sau:\n form: là một dictionary chứa key và value là các tham số (parameters) và giá trị của chúng args: chứa nội dung của câu query qua URL (những nội dung sau dấu ? trên URL) cookies: dictionary chứa nội dung của cookies files: dữ liệu liên quan tới upload file method: method của request  Đừng lo lắng, chúng ta sẽ thử một số thứ ngay bây giờ!\nDuyệt dữ liệu trong dictionary Đầu tiên ta ôn lại một chút về cách duyệt dữ liệu trong dictionary:\nLưu file này lại và chạy thử:\nperson = { 'name': 'Nguyen Van Chien', 'age': 20, 'address': 'Ha noi, Viet Nam', 'job': 'Web Developer' } print 'Step 1. Get all keys of this dict:' print str(person.keys()) print 'So, person.keys() return a list which contains all keys of it' print '---' print 'Step 2. Get all keys and values:' for key in person.keys(): # for each key print '%s: %s' % (key, person[key])  Kết quả:\nStep 1. Get all keys of this dict: ['job', 'age', 'name', 'address'] So, person.keys return a list which contain all keys of person --- Step 2. Get all keys and values: job: Web Developer age: 20 name: Nguyen Van Chien address: Ha noi, Viet Nam  Như vậy, cơ bản ta có thể duyệt tất cả các dữ liệu trong 1 dict tudien như sau:\nfor key in tudien.keys(): print '%s: %s' % (key, tudien[key])  Cách khác:\nfor key, value in tudien.items(): print '%s: %s' % (key, value)  Thử nghiệm Ở phần này ta sẽ xem thử form, args, method hoạt động như thế nào.\nChuẩn bị template Sửa lại file hello.html thành như sau:\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;{{ url_for('static', filename = 'style.css') }}\u0026quot; /\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- Method --\u0026gt; \u0026lt;h1\u0026gt;Method: POST\u0026lt;/h1\u0026gt; \u0026lt;!-- Request --\u0026gt; \u0026lt;h1\u0026gt;Request\u0026lt;/h1\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;Key\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Value\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;some key\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;some value\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;!-- Args --\u0026gt; \u0026lt;h2\u0026gt;Args\u0026lt;/h1\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;Key\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Value\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;some key\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;some value\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  Chạy thử:\nOk, vậy là ta đã có 1 template khá ổn để thử nghiệm.\nThay dữ liệu: Sửa file hello.html như sau:\n... \u0026lt;!-- Method --\u0026gt; \u0026lt;h1\u0026gt;Method: {{ request.method }}\u0026lt;/h1\u0026gt; \u0026lt;!-- Request --\u0026gt; \u0026lt;h1\u0026gt;Request\u0026lt;/h1\u0026gt; \u0026lt;table border=1\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;Key\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Value\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; {% for key, value in request.form.items() %} \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;{{ key }}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{ value }}\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; {% endfor %} \u0026lt;/table\u0026gt; \u0026lt;!-- Args --\u0026gt; \u0026lt;h1\u0026gt;Args\u0026lt;/h1\u0026gt; \u0026lt;table border=1\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;Key\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Value\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; {% for key, value in request.args.items() %} \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;{{ key }}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{ value }}\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; {% endfor %} \u0026lt;/table\u0026gt; ...  Chúng ta có gì mới nào?\nVới vòng for ở python như thế này:\nfor key, value in request.args.items(): print '\u0026lt;tr\u0026gt;' print '\u0026lt;td\u0026gt;%s\u0026lt;/td\u0026gt;' % key print '\u0026lt;td\u0026gt;%s\u0026lt;/td\u0026gt;' % value print '\u0026lt;/tr\u0026gt;'  Vào trong template sẽ thành như thế này:\n{% for key, value in request.args.items() %} \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;{{ key }}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{ value }}\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; {% endfor %}  Dễ nhìn và trong sáng hơn nhiều phải không nào?\nSửa lại route Phần thử nghiệm ta sẽ gửi cả request dạng GET và POST, vì thế ta cần sửa lại route một chút để chấp nhận cả 2 loại request này:\nSửa file hello.py\n... @app.route('/', methods=['GET', 'POST']) def hello(): ...  Cài đặt Postman Ta sẽ dùng Postman để giả lập request, vậy nên nếu chưa có thì cài ngay đi nhé!\nBắt đầu thử nghiệm: Ta sẽ thử bắn 1 số request với Postman để xem method, form, args là gì?\nĐầu tiên: Kết quả (xem ở phần Preview): Như vậy:\n request.method chính là method của request gửi lên. request.form chứa dữ liệu ở phần body của request (dưới dạng dictionary)  Tiếp theo: Kết quả: Ta có thể thấy request.args đã lấy phần URL của request ?city=Ha Noi\u0026amp;country=Viet Nam và chuyển thành dạng dict như sau:\n{ 'city': 'Ha Noi', 'country': 'Viet Nam' }  Bài tập: Viết CT Sau khi nhận request như sau: Thì in ra kết quả sau: Chỉ in ra tên của người nhập, không in họ\n "
},
{
	"uri": "/chapters/flask-co-ban/",
	"title": "Flask cơ bản",
	"tags": [],
	"description": "",
	"content": " Ngày 03 Flask cơ bản Học cách sử dụng một số hàm cơ bản của Flask\n"
},
{
	"uri": "/chapters/bang-du-lieu/gioi-thieu-co-so-du-lieu/",
	"title": "Làm quen với cơ sở dữ liệu",
	"tags": [],
	"description": "",
	"content": " Mọi thứ là dữ liệu Cho ai còn chưa hiểu dữ liệu là gì. Dữ liệu tồn tại quanh ta, nó có thể là tên một ai đó, là một số điện thoại, là hình ảnh, âm thanh,.. Tóm lại, mọi thứ mang thông tin đều có dữ liệu.\nVậy cơ sở dữ liệu là gì? Tiếng anh: Database Cơ sở dữ liệu là tập hợp các dữ liệu được tổ chức theo một cách nào đó. Người dùng có thể đọc, chỉnh sửa, xóa dữ liệu trên đó qua một công cụ quản lý.\nCó ví dụ nào dễ hiểu hơn không? Bạn có 1 cuốn sổ ghi lại những gì cần làm (To do List) Với cuổn sổ đó bạn có thể xem, sửa, xóa các việc trong danh sách đó.\nVậy:\n Việc cần làm là dữ liệu Các việc cần làm được tổ chức dưới dạng danh sách theo ngày là cơ dở dữ liệu. Cuốn sổ và cây bút là nơi lưu trữ và quản lý dữ liệu  Cơ sở dữ liệu dạng bảng Có một cách biểu diễn dữ liệu rất phổ biến và trực quan đó là biểu diễn theo dạng bảng. Ví dụ ta có 1 bảng biểu diễn danh sách một lớp học như sau:\n   Mã SV Họ Tên Ngày sinh SĐT     20150311 Nguyễn Văn An 01/01/1997 0123456789   20136312 Trần Bảo Bình 02/03/1997 0131341414   20150362 Nguyễn Văn Chiến 06/03/1992 0466778899    Đây là một bảng dữ liệu với các cột (column) đại diện cho đặc điểm của đối tượng học sinh (Field, Attribute). Thông tin của một học sinh sẽ nằm trên cùng một hàng (row)\nTập hợp các bảng liên quan lại với nhau ta có được một Cơ sở dữ liệu\nTới đây ta có thể hình dung được 1 file excel cũng là một cơ sở dữ liệu. So easy, right?\n"
},
{
	"uri": "/chapters/bang-du-lieu/gioi-thieu-sql/",
	"title": "Giới thiệu SQL",
	"tags": [],
	"description": "",
	"content": " SQL là gì? SQL = Structured Query Language\nSQL là một ngôn ngữ giúp bạn tương tác (tìm kiếm, thêm, sửa, xóa,..) trên Cơ sở dữ liệu. Hệ quản trị CSDL Tiếng anh: Database Management System - DBMS\nLà các chương trình/hệ thống được thiết kế để quản lý CSDL. Các chương trình này hỗ trợ thêm, sửa, xóa, tìm kiếm trong CSDL và chúng thường sử dụng ngôn ngữ SQL.\nMột số DBMS phổ biến: MySQL, Oracle, PostreSQL, SQL Server,..\nCác DBMS phổ biến nói trên thường khá phức tạp để sử dụng. Để đơn giản, chúng ta sẽ sử dụng một DBMS nhỏ gọn hơn là SQLite\n Cài đặt SQLite Cài SQLite trên Ubuntu 18.04 khá đơn giản. Ta chạy câu lệnh sau:\nsudo apt-get update sudo apt-get install sqlite3  Có thể kiểm tra xem sqlite3 đã được cài đặt hay chưa\nsqlite3 --version  Kết quả: Cài đặt SQLite Browser Chúng ta sẽ cài thêm một công cụ GUI nữa giúp cho việc quản lý DB dễ dàng hơn:\nsudo apt-get install sqlitebrowser  Một phần mềm DB Browser for SQLite sẽ được cài vào máy, giao diện như sau:\nClick New Database và điền tên file database.sqlite3 (file này sẽ chứa dữ liệu). Lưu tại thư mục Home\nHệ thống sẽ hỏi về việc tạo thêm bảng mới, tạm thời ta bỏ qua và ấn Cancel\nOk, vậy là xong phần setup database!\n"
},
{
	"uri": "/chapters/bang-du-lieu/",
	"title": "Bảng dữ liệu",
	"tags": [],
	"description": "",
	"content": " Ngày 04 Bảng dữ liệu Học cách tạo bảng với SQL và sử dụng SQL trong Python\n"
},
{
	"uri": "/chapters/",
	"title": "30 Ngày Flask",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/",
	"title": "Học Python",
	"tags": [],
	"description": "",
	"content": " Học Python "
},
{
	"uri": "/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]